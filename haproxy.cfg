global
  log stdout format raw local0

defaults
  mode http
  log global
  option httplog
  option dontlognull
  option forwardfor header X-Forwarded-For if-none
  timeout connect 5s
  timeout client 30s
  timeout server 30s

# HTTP entrypoint
frontend fe_http
  bind *:80

  # --- Bonus: simple burst rate limit (10 reqs / 10s per IP) ---
  # stick-table type ip size 100k expire 10s store http_req_rate(10s)
  # http-request track-sc0 src
  # http-request deny deny_status 429 if { sc_http_req_rate(0) gt 10 }

  acl is_api path_beg /api
  acl is_web path_beg /web

  use_backend be_api if is_api
  use_backend be_web if is_web
  default_backend be_api

# API backend (2 servers behind LB)
backend be_api
  # Core requirement: load balancing algorithm (change as you wish)
  balance roundrobin
  # Alternative algorithms to try:
  # balance leastconn
  # balance source

  # Bonus: sticky sessions via cookie
  cookie SRV insert indirect nocache

  # Health checks
  option httpchk GET 
  http-check expect status 200

  # Identify chosen server for demos
  http-response set-header X-Served-By %[srv_name]

  # Bonus: weighted servers (api1 gets more traffic)
  server api1 whoami1:80 check inter 2s fall 3 rise 2 cookie s1 weight 3
  server api2 whoami2:80 check inter 2s fall 3 rise 2 cookie s2 weight 1

# Path-based routing target (/web)
backend be_web
  # balance leastconn
  balance roundrobin

   # Bonus: sticky sessions via cookie
  cookie SRV insert indirect nocache
  option httpchk GET /
  http-check expect status 200
  http-response set-header X-Served-By %[srv_name]
  server web1 web:80 check

# Stats dashboard
listen stats
  bind *:8404
  mode http
  stats enable
  stats uri /stats
  stats refresh 2s
  stats show-node
  stats auth admin:admin
